name: Build and Test Mode

on:
  workflow_call:
    inputs:
      app:
        description: "Application to build and test"
        required: true
        type: string
      mode:
        description: "Mode to build and test"
        required: true
        type: string
    secrets:
      TURBO_TOKEN:
        required: false
      TURBO_TEAM:
        required: false
      TURBO_API:
        required: false
    outputs:
      success:
        description: "Whether any build/test succeeded"
        value: ${{ jobs.ci-status.outputs.success }}

env:
  TURBO_TELEMETRY_DISABLED: 1
  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
  TURBO_TEAM: ${{ secrets.TURBO_TEAM }}
  TURBO_API: ${{ secrets.TURBO_API }}
  BUILD_ID: ${{ github.run_id }}-${{ github.run_number }}-${{ inputs.mode }}

jobs:
  # Build on Linux
  linux-build:
    name: Linux Build
    runs-on: ubuntu-latest
    outputs:
      success: ${{ steps.build-result.outputs.success }}
      artifact_name: ${{ inputs.app }}-${{ inputs.mode }}-linux-${{ env.BUILD_ID }}
      release_tag: ${{ steps.build-result.outputs.release_tag || '' }}
      version: ${{ steps.build-result.outputs.version || '' }}
    steps:
      # Linux-specific dependencies
      - name: Install Linux dependencies
        if: inputs.app == 'tauri' || inputs.app == 'tauri-v1'
        run: |
          sudo tee -a /etc/apt/sources.list > /dev/null <<EOT
          deb http://archive.ubuntu.com/ubuntu jammy main universe
          EOT
          sudo apt-get update
          sudo apt-get install -y \
            pkg-config \
            libgtk-3-dev \
            libwebkit2gtk-4.0-dev \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            libglib2.0-dev \
            libsoup-2.4-1 \
            libsoup2.4-dev \
            libjavascriptcoregtk-4.0-dev \
            libjavascriptcoregtk-4.1-dev
          echo "--- Verifying pkg-config and .pc file locations ---"
          which pkg-config
          echo "PKG_CONFIG_PATH (before setting): $PKG_CONFIG_PATH"
          # Common paths for .pc files on Ubuntu
          PC_PATH1="/usr/lib/x86_64-linux-gnu/pkgconfig"
          PC_PATH2="/usr/share/pkgconfig"
          PC_PATH3="/lib/x86_64-linux-gnu/pkgconfig"

          EXPORT_PKG_CONFIG_PATH=""
          if [ -d "$PC_PATH1" ]; then
            EXPORT_PKG_CONFIG_PATH="$PC_PATH1"
          fi
          if [ -d "$PC_PATH2" ]; then
            if [ -n "$EXPORT_PKG_CONFIG_PATH" ]; then
              EXPORT_PKG_CONFIG_PATH="$EXPORT_PKG_CONFIG_PATH:$PC_PATH2"
            else
              EXPORT_PKG_CONFIG_PATH="$PC_PATH2"
            fi
          fi
          if [ -d "$PC_PATH3" ]; then
            if [ -n "$EXPORT_PKG_CONFIG_PATH" ]; then
              EXPORT_PKG_CONFIG_PATH="$EXPORT_PKG_CONFIG_PATH:$PC_PATH3"
            else
              EXPORT_PKG_CONFIG_PATH="$PC_PATH3"
            fi
          fi

          if [ -n "$PKG_CONFIG_PATH" ]; then
            if [ -n "$EXPORT_PKG_CONFIG_PATH" ]; then
              export PKG_CONFIG_PATH="$EXPORT_PKG_CONFIG_PATH:$PKG_CONFIG_PATH"
            fi
          else
            if [ -n "$EXPORT_PKG_CONFIG_PATH" ]; then
              export PKG_CONFIG_PATH="$EXPORT_PKG_CONFIG_PATH"
            fi
          fi
          echo "PKG_CONFIG_PATH (after setting): $PKG_CONFIG_PATH"
          find /usr /lib -name "glib-2.0.pc" -ls 2>/dev/null || echo "glib-2.0.pc not found in /usr or /lib"
          echo "--- End verification ---"

      # Checkout and setup
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Environment
        uses: ./.github/workflows/actions/setup-workspace
        with:
          node-version: "20"

      # Download shared packages
      - name: Download shared packages
        uses: actions/download-artifact@v4
        with:
          name: shared-packages
          path: packages

      # Cargo setup for Tauri
      - name: Setup Cargo Cache
        if: inputs.app == 'tauri' || inputs.app == 'tauri-v1'
        shell: bash
        run: |
          mkdir -p ~/.cargo/{registry,git}
          echo '[net]
          git-fetch-with-cli = true
          retry = 3
          [build]
          jobs = 2' > ~/.cargo/config.toml

      # Build application
      - name: Build ${{ inputs.app }}:${{ inputs.mode }}
        id: build-app
        shell: bash
        run: |
          PACKAGE_NAME="zubridge-${{ inputs.app }}-example"
          APP_DIR_NAME="${{ inputs.app }}-example"
          if [ "${{ inputs.app }}" == "electron" ]; then
            pnpm run build:${{ inputs.app }}-${{ inputs.mode }} -- -l
          else
            echo "--- Initial check: Listing contents of $GITHUB_WORKSPACE/apps/$APP_DIR_NAME ---"
            ls -la "$GITHUB_WORKSPACE/apps/$APP_DIR_NAME"
            echo "--- Initial check: Listing contents of $GITHUB_WORKSPACE/apps/$APP_DIR_NAME/src-tauri ---"
            ls -la "$GITHUB_WORKSPACE/apps/$APP_DIR_NAME/src-tauri"
            echo "--- End Initial check ---"

            # Run Vite build first
            echo "--- Running Vite build for ${{ inputs.app }}-${{ inputs.mode }} ---"
            pnpm exec cross-env ZUBRIDGE_MODE=${{ inputs.mode }} pnpm --filter=$PACKAGE_NAME exec vite build

            # Determine config file and property name
            RELATIVE_CONFIG_FILE_PATH="apps/$APP_DIR_NAME/src-tauri/tauri.conf.json"
            ABSOLUTE_CONFIG_FILE_PATH_SHELL="$GITHUB_WORKSPACE/$RELATIVE_CONFIG_FILE_PATH"
            DIST_PROPERTY_NAME="distDir" # Default for v1
            if [ "${{ inputs.app }}" == "tauri" ]; then # Tauri v2 uses frontendDist
              DIST_PROPERTY_NAME="frontendDist"
            fi

            # Calculate absolute path for dist dir
            ABSOLUTE_DIST_PATH="$GITHUB_WORKSPACE/apps/$APP_DIR_NAME/dist"

            # Shell debugging: Check if file exists and list directory
            echo "--- Shell: Checking if config file exists at $ABSOLUTE_CONFIG_FILE_PATH_SHELL ---"
            if [ -f "$ABSOLUTE_CONFIG_FILE_PATH_SHELL" ]; then
              echo "--- Shell: Config file FOUND at $ABSOLUTE_CONFIG_FILE_PATH_SHELL ---"
            else
              echo "--- Shell: Config file NOT FOUND at $ABSOLUTE_CONFIG_FILE_PATH_SHELL ---"
            fi
            echo "--- Shell: Listing contents of $(dirname "$ABSOLUTE_CONFIG_FILE_PATH_SHELL") ---"
            ls -la "$(dirname "$ABSOLUTE_CONFIG_FILE_PATH_SHELL")"
            echo "--- End Shell Debugging ---"

            echo "--- Modifying $ABSOLUTE_CONFIG_FILE_PATH_SHELL to use absolute dist path: $ABSOLUTE_DIST_PATH for property $DIST_PROPERTY_NAME ---"
            node -e "\
              const fs = require('fs');\
              const path = require('path');\
              const workspaceDir = process.env.GITHUB_WORKSPACE;\
              const configFile = path.join(workspaceDir, '$RELATIVE_CONFIG_FILE_PATH');\
              console.log('Node: Attempting to read config from:', configFile);\
              try { \
                const config = JSON.parse(fs.readFileSync(configFile, 'utf8'));\
                config.build.$DIST_PROPERTY_NAME = '$ABSOLUTE_DIST_PATH';\
                fs.writeFileSync(configFile, JSON.stringify(config, null, 2));\
                console.log('Node: Successfully updated $DIST_PROPERTY_NAME in', configFile);\
              } catch (err) { \
                console.error('Node: Error processing config file:', configFile, err); \
                process.exit(1); \
              }"

            echo "--- Contents of $ABSOLUTE_CONFIG_FILE_PATH_SHELL after modification ---"
            cat "$ABSOLUTE_CONFIG_FILE_PATH_SHELL"
            echo "--- End of modified config ---"

            echo "--- Debugging Cargo Paths for $PACKAGE_NAME ---"
            echo "Current PWD:"
            pwd
            echo "GITHUB_WORKSPACE: $GITHUB_WORKSPACE"
            echo "Listing $GITHUB_WORKSPACE/packages:"
            ls -la "$GITHUB_WORKSPACE/packages" || echo "Failed to list $GITHUB_WORKSPACE/packages"
            echo "Listing $GITHUB_WORKSPACE/packages/tauri-plugin:"
            ls -la "$GITHUB_WORKSPACE/packages/tauri-plugin" || echo "Failed to list $GITHUB_WORKSPACE/packages/tauri-plugin"
            echo "Verifying Cargo.toml content in app ($APP_DIR_NAME):"
            cat "$GITHUB_WORKSPACE/apps/$APP_DIR_NAME/src-tauri/Cargo.toml" || echo "Failed to cat $GITHUB_WORKSPACE/apps/$APP_DIR_NAME/src-tauri/Cargo.toml"
            echo "--- End Cargo Path Debugging ---"

            # Now run Tauri build
            echo "--- Running Tauri build for ${{ inputs.app }}-${{ inputs.mode }} ---"
            echo "Current directory before tauri build: $(pwd)"
            echo "Listing contents of GITHUB_WORKSPACE parent ($GITHUB_WORKSPACE/..):"
            ls -la "$GITHUB_WORKSPACE/.." || echo "Failed to list $GITHUB_WORKSPACE/.."
            pnpm exec cross-env ZUBRIDGE_MODE=${{ inputs.mode }} pnpm --filter=$PACKAGE_NAME exec pnpm tauri build
          fi
        continue-on-error: true

      # Process build result for Linux
      - name: Process Build Result
        id: build-result
        uses: ./.github/workflows/actions/process-build-result
        with:
          build_step_id: build-app
          build_outcome: ${{ steps.build-app.outcome }}
          shell_type: bash

      # Upload artifacts
      - name: Upload Artifacts
        if: steps.build-result.outputs.success == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.app }}-${{ inputs.mode }}-linux-${{ env.BUILD_ID }}
          path: |
            ${{ inputs.app == 'electron' && format('apps/{0}-example/dist-{1}', inputs.app, inputs.mode) || format('apps/{0}-example/src-tauri/target/release/bundle/', inputs.app) }}
          retention-days: 1
          if-no-files-found: warn

      # Debug on failure
      - name: Debug on Failure
        uses: stateful/vscode-server-action@v1.1.0
        if: failure()
        with:
          timeout: "180000"

  # Build on macOS
  macos-build:
    name: macOS Build
    runs-on: macOS-latest
    outputs:
      success: ${{ steps.build-result.outputs.success }}
      artifact_name: ${{ inputs.app }}-${{ inputs.mode }}-macos-${{ env.BUILD_ID }}
    steps:
      # Checkout and setup
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Environment
        uses: ./.github/workflows/actions/setup-workspace
        with:
          node-version: "20"

      # Download shared packages
      - name: Download shared packages
        uses: actions/download-artifact@v4
        with:
          name: shared-packages
          path: packages

      # Cargo setup for Tauri
      - name: Setup Cargo Cache
        if: inputs.app == 'tauri' || inputs.app == 'tauri-v1'
        shell: bash
        run: |
          mkdir -p ~/.cargo/{registry,git}
          echo '[net]
          git-fetch-with-cli = true
          retry = 3
          [build]
          jobs = 2' > ~/.cargo/config.toml

      # Build application
      - name: Build ${{ inputs.app }}:${{ inputs.mode }}
        id: build-app
        shell: bash
        run: |
          PACKAGE_NAME="zubridge-${{ inputs.app }}-example"
          APP_DIR_NAME="${{ inputs.app }}-example"
          if [ "${{ inputs.app }}" == "electron" ]; then
            pnpm run build:${{ inputs.app }}-${{ inputs.mode }} -- -m
          else
            echo "--- Initial check: Listing contents of $GITHUB_WORKSPACE/apps/$APP_DIR_NAME ---"
            ls -la "$GITHUB_WORKSPACE/apps/$APP_DIR_NAME"
            echo "--- Initial check: Listing contents of $GITHUB_WORKSPACE/apps/$APP_DIR_NAME/src-tauri ---"
            ls -la "$GITHUB_WORKSPACE/apps/$APP_DIR_NAME/src-tauri"
            echo "--- End Initial check ---"

            # Run Vite build first
            echo "--- Running Vite build for ${{ inputs.app }}-${{ inputs.mode }} ---"
            pnpm exec cross-env ZUBRIDGE_MODE=${{ inputs.mode }} pnpm --filter=$PACKAGE_NAME exec vite build

            # Determine config file and property name
            RELATIVE_CONFIG_FILE_PATH="apps/$APP_DIR_NAME/src-tauri/tauri.conf.json"
            ABSOLUTE_CONFIG_FILE_PATH_SHELL="$GITHUB_WORKSPACE/$RELATIVE_CONFIG_FILE_PATH"
            DIST_PROPERTY_NAME="distDir" # Default for v1
            if [ "${{ inputs.app }}" == "tauri" ]; then # Tauri v2 uses frontendDist
              DIST_PROPERTY_NAME="frontendDist"
            fi

            # Calculate absolute path for dist dir
            ABSOLUTE_DIST_PATH="$GITHUB_WORKSPACE/apps/$APP_DIR_NAME/dist"

            # Shell debugging: Check if file exists and list directory
            echo "--- Shell: Checking if config file exists at $ABSOLUTE_CONFIG_FILE_PATH_SHELL ---"
            if [ -f "$ABSOLUTE_CONFIG_FILE_PATH_SHELL" ]; then
              echo "--- Shell: Config file FOUND at $ABSOLUTE_CONFIG_FILE_PATH_SHELL ---"
            else
              echo "--- Shell: Config file NOT FOUND at $ABSOLUTE_CONFIG_FILE_PATH_SHELL ---"
            fi
            echo "--- Shell: Listing contents of $(dirname "$ABSOLUTE_CONFIG_FILE_PATH_SHELL") ---"
            ls -la "$(dirname "$ABSOLUTE_CONFIG_FILE_PATH_SHELL")"
            echo "--- End Shell Debugging ---"

            echo "--- Modifying $ABSOLUTE_CONFIG_FILE_PATH_SHELL to use absolute dist path: $ABSOLUTE_DIST_PATH for property $DIST_PROPERTY_NAME ---"
            node -e "\
              const fs = require('fs');\
              const path = require('path');\
              const workspaceDir = process.env.GITHUB_WORKSPACE;\
              const configFile = path.join(workspaceDir, '$RELATIVE_CONFIG_FILE_PATH');\
              console.log('Node: Attempting to read config from:', configFile);\
              try { \
                const config = JSON.parse(fs.readFileSync(configFile, 'utf8'));\
                config.build.$DIST_PROPERTY_NAME = '$ABSOLUTE_DIST_PATH';\
                fs.writeFileSync(configFile, JSON.stringify(config, null, 2));\
                console.log('Node: Successfully updated $DIST_PROPERTY_NAME in', configFile);\
              } catch (err) { \
                console.error('Node: Error processing config file:', configFile, err); \
                process.exit(1); \
              }"

            echo "--- Contents of $ABSOLUTE_CONFIG_FILE_PATH_SHELL after modification ---"
            cat "$ABSOLUTE_CONFIG_FILE_PATH_SHELL"
            echo "--- End of modified config ---"

            echo "--- Debugging Cargo Paths for $PACKAGE_NAME ---"
            echo "Current PWD:"
            pwd
            echo "GITHUB_WORKSPACE: $GITHUB_WORKSPACE"
            echo "Listing $GITHUB_WORKSPACE/packages:"
            ls -la "$GITHUB_WORKSPACE/packages" || echo "Failed to list $GITHUB_WORKSPACE/packages"
            echo "Listing $GITHUB_WORKSPACE/packages/tauri-plugin:"
            ls -la "$GITHUB_WORKSPACE/packages/tauri-plugin" || echo "Failed to list $GITHUB_WORKSPACE/packages/tauri-plugin"
            echo "Verifying Cargo.toml content in app ($APP_DIR_NAME):"
            cat "$GITHUB_WORKSPACE/apps/$APP_DIR_NAME/src-tauri/Cargo.toml" || echo "Failed to cat $GITHUB_WORKSPACE/apps/$APP_DIR_NAME/src-tauri/Cargo.toml"
            echo "--- End Cargo Path Debugging ---"

            # Now run Tauri build
            echo "--- Running Tauri build for ${{ inputs.app }}-${{ inputs.mode }} ---"
            echo "Current directory before tauri build: $(pwd)"
            echo "Listing contents of GITHUB_WORKSPACE parent ($GITHUB_WORKSPACE/..):"
            ls -la "$GITHUB_WORKSPACE/.." || echo "Failed to list $GITHUB_WORKSPACE/.."
            pnpm exec cross-env ZUBRIDGE_MODE=${{ inputs.mode }} pnpm --filter=$PACKAGE_NAME exec pnpm tauri build
          fi
        continue-on-error: true

      # Process build result for macOS
      - name: Process Build Result
        id: build-result
        uses: ./.github/workflows/actions/process-build-result
        with:
          build_step_id: build-app
          build_outcome: ${{ steps.build-app.outcome }}
          shell_type: bash

      # Upload artifacts
      - name: Upload Artifacts
        if: steps.build-result.outputs.success == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.app }}-${{ inputs.mode }}-macos-${{ env.BUILD_ID }}
          path: |
            ${{ inputs.app == 'electron' && format('apps/{0}-example/dist-{1}', inputs.app, inputs.mode) || format('apps/{0}-example/src-tauri/target/release/bundle/', inputs.app) }}
          retention-days: 1
          if-no-files-found: warn

      # Debug on failure
      - name: Debug on Failure
        uses: stateful/vscode-server-action@v1.1.0
        if: failure()
        with:
          timeout: "180000"

  # Build on Windows
  windows-build:
    name: Windows Build
    runs-on: windows-latest
    outputs:
      success: ${{ steps.build-result.outputs.success }}
      artifact_name: ${{ inputs.app }}-${{ inputs.mode }}-windows-${{ env.BUILD_ID }}
    steps:
      # Checkout and setup
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Environment
        uses: ./.github/workflows/actions/setup-workspace
        with:
          node-version: "20"

      # Download shared packages
      - name: Download shared packages
        uses: actions/download-artifact@v4
        with:
          name: shared-packages
          path: packages

      # Cargo setup for Tauri
      - name: Setup Cargo Cache
        if: inputs.app == 'tauri' || inputs.app == 'tauri-v1'
        shell: bash
        run: |
          mkdir -p ~/.cargo/{registry,git}
          echo '[net]
          git-fetch-with-cli = true
          retry = 3
          [build]
          jobs = 2' > ~/.cargo/config.toml

      # Build application
      - name: Build ${{ inputs.app }}:${{ inputs.mode }}
        id: build-app
        shell: bash
        run: |
          PACKAGE_NAME="zubridge-${{ inputs.app }}-example"
          APP_DIR_NAME="${{ inputs.app }}-example"
          if [ "${{ inputs.app }}" == "electron" ]; then
            pnpm run build:${{ inputs.app }}-${{ inputs.mode }} -- -w
          else
            echo "--- Initial check: Listing contents of $GITHUB_WORKSPACE/apps/$APP_DIR_NAME ---"
            ls -la "$GITHUB_WORKSPACE/apps/$APP_DIR_NAME"
            echo "--- Initial check: Listing contents of $GITHUB_WORKSPACE/apps/$APP_DIR_NAME/src-tauri ---"
            ls -la "$GITHUB_WORKSPACE/apps/$APP_DIR_NAME/src-tauri"
            echo "--- End Initial check ---"

            # Run Vite build first
            echo "--- Running Vite build for ${{ inputs.app }}-${{ inputs.mode }} ---"
            pnpm exec cross-env ZUBRIDGE_MODE=${{ inputs.mode }} pnpm --filter=$PACKAGE_NAME exec vite build

            # Determine config file and property name
            RELATIVE_CONFIG_FILE_PATH="apps/$APP_DIR_NAME/src-tauri/tauri.conf.json"
            ABSOLUTE_CONFIG_FILE_PATH_SHELL="$GITHUB_WORKSPACE/$RELATIVE_CONFIG_FILE_PATH"
            DIST_PROPERTY_NAME="distDir" # Default for v1
            if [ "${{ inputs.app }}" == "tauri" ]; then # Tauri v2 uses frontendDist
              DIST_PROPERTY_NAME="frontendDist"
            fi

            # Calculate absolute path for dist dir
            ABSOLUTE_DIST_PATH="$GITHUB_WORKSPACE/apps/$APP_DIR_NAME/dist"

            # Shell debugging: Check if file exists and list directory
            echo "--- Shell: Checking if config file exists at $ABSOLUTE_CONFIG_FILE_PATH_SHELL ---"
            if [ -f "$ABSOLUTE_CONFIG_FILE_PATH_SHELL" ]; then
              echo "--- Shell: Config file FOUND at $ABSOLUTE_CONFIG_FILE_PATH_SHELL ---"
            else
              echo "--- Shell: Config file NOT FOUND at $ABSOLUTE_CONFIG_FILE_PATH_SHELL ---"
            fi
            echo "--- Shell: Listing contents of $(dirname "$ABSOLUTE_CONFIG_FILE_PATH_SHELL") ---"
            ls -la "$(dirname "$ABSOLUTE_CONFIG_FILE_PATH_SHELL")"
            echo "--- End Shell Debugging ---"

            echo "--- Modifying $ABSOLUTE_CONFIG_FILE_PATH_SHELL to use absolute dist path: $ABSOLUTE_DIST_PATH for property $DIST_PROPERTY_NAME ---"
            node -e "\
              const fs = require('fs');\
              const path = require('path');\
              const workspaceDir = process.env.GITHUB_WORKSPACE;\
              const configFile = path.join(workspaceDir, '$RELATIVE_CONFIG_FILE_PATH');\
              console.log('Node: Attempting to read config from:', configFile);\
              try { \
                const config = JSON.parse(fs.readFileSync(configFile, 'utf8'));\
                config.build.$DIST_PROPERTY_NAME = '$ABSOLUTE_DIST_PATH';\
                fs.writeFileSync(configFile, JSON.stringify(config, null, 2));\
                console.log('Node: Successfully updated $DIST_PROPERTY_NAME in', configFile);\
              } catch (err) { \
                console.error('Node: Error processing config file:', configFile, err); \
                process.exit(1); \
              }"

            echo "--- Contents of $ABSOLUTE_CONFIG_FILE_PATH_SHELL after modification ---"
            cat "$ABSOLUTE_CONFIG_FILE_PATH_SHELL"
            echo "--- End of modified config ---"

            echo "--- Debugging Cargo Paths for $PACKAGE_NAME ---"
            echo "Current PWD:"
            pwd
            echo "GITHUB_WORKSPACE: $GITHUB_WORKSPACE"
            echo "Listing $GITHUB_WORKSPACE/packages:"
            ls -la "$GITHUB_WORKSPACE/packages" || echo "Failed to list $GITHUB_WORKSPACE/packages"
            echo "Listing $GITHUB_WORKSPACE/packages/tauri-plugin:"
            ls -la "$GITHUB_WORKSPACE/packages/tauri-plugin" || echo "Failed to list $GITHUB_WORKSPACE/packages/tauri-plugin"
            echo "Verifying Cargo.toml content in app ($APP_DIR_NAME):"
            cat "$GITHUB_WORKSPACE/apps/$APP_DIR_NAME/src-tauri/Cargo.toml" || echo "Failed to cat $GITHUB_WORKSPACE/apps/$APP_DIR_NAME/src-tauri/Cargo.toml"
            echo "--- End Cargo Path Debugging ---"

            # Now run Tauri build
            echo "--- Running Tauri build for ${{ inputs.app }}-${{ inputs.mode }} ---"
            echo "Current directory before tauri build: $(pwd)"
            echo "Listing contents of GITHUB_WORKSPACE parent ($GITHUB_WORKSPACE/..):"
            ls -la "$GITHUB_WORKSPACE/.." || echo "Failed to list $GITHUB_WORKSPACE/.."
            pnpm exec cross-env ZUBRIDGE_MODE=${{ inputs.mode }} pnpm --filter=$PACKAGE_NAME exec pnpm tauri build
          fi
        continue-on-error: true

      # Process build result for Windows
      - name: Process Build Result
        id: build-result
        uses: ./.github/workflows/actions/process-build-result
        with:
          build_step_id: build-app
          build_outcome: ${{ steps.build-app.outcome }}
          shell_type: pwsh

      # Upload artifacts
      - name: Upload Artifacts
        if: steps.build-result.outputs.success == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.app }}-${{ inputs.mode }}-windows-${{ env.BUILD_ID }}
          path: |
            ${{ inputs.app == 'electron' && format('apps/{0}-example/dist-{1}', inputs.app, inputs.mode) || format('apps/{0}-example/src-tauri/target/release/bundle/', inputs.app) }}
          retention-days: 1
          if-no-files-found: warn

      # Debug on failure
      - name: Debug on Failure
        uses: stateful/vscode-server-action@v1.1.0
        if: failure()
        with:
          timeout: "180000"

  # E2E Tests for Linux
  linux-test:
    name: Linux E2E
    if: needs.linux-build.outputs.success == 'true'
    needs: [linux-build]
    runs-on: ubuntu-latest
    env:
      RELEASE_TAG: ${{ needs.linux-build.outputs.release_tag || format('zubridge-v{0}', needs.linux-build.outputs.version || github.run_id) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'

      - name: Set up pnpm
        uses: pnpm/action-setup@v3
        with:
          run_install: false

      - name: Get pnpm store directory
        id: pnpm_store_path_step_linux
        shell: bash
        run: |
          STORE_PATH_VALUE=$(pnpm store path --silent)
          echo "STORE_PATH=$STORE_PATH_VALUE" >> $GITHUB_ENV
          echo "store_path=$STORE_PATH_VALUE" >> $GITHUB_OUTPUT

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm_store_path_step_linux.outputs.store_path }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install Rust toolchain
        if: inputs.app == 'tauri' || inputs.app == 'tauri-v1'
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Install Linux dependencies for Tauri & E2E (including WebKitWebDriver)
        if: inputs.app == 'tauri' || inputs.app == 'tauri-v1'
        shell: bash
        run: |
          sudo apt-get update
          COMMON_DEPS="\
            pkg-config \
            libgtk-3-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            libglib2.0-dev \
            libsoup-2.4-1 \
            libsoup2.4-dev \
            xvfb \
            scrot"

          TAURI_V1_DEPS="\
            libwebkit2gtk-4.0-dev \
            libwebkit2gtk-driver \
            libjavascriptcoregtk-4.0-dev"

          TAURI_V2_DEPS="\
            libwebkit2gtk-4.1-dev \
            libjavascriptcoregtk-4.1-dev"

          if [[ "${{ inputs.app }}" == "tauri-v1" ]]; then
            echo "Installing dependencies for Tauri v1"
            # For Tauri v1 on Ubuntu 24.04, we expect libwebkit2gtk-4.0-dev and related to fail.
            # We'll attempt to install them but allow failure, then install the 4.1 versions as a fallback.
            # This is a temporary workaround pending official Tauri v1 support for Ubuntu 24.04's newer WebKit.
            echo "Attempting to install Tauri v1 specific WebKit 4.0 packages (expected to fail on Ubuntu 24.04)..."
            sudo apt-get install -y --no-install-recommends $COMMON_DEPS $TAURI_V1_DEPS || echo "Known issue: Failed to install some Tauri v1 WebKit 4.0 packages on Ubuntu 24.04. Continuing with 4.1 as fallback."
            echo "Installing WebKit 4.1 packages as a fallback for Tauri v1 on Ubuntu 24.04..."
            sudo apt-get install -y --no-install-recommends $COMMON_DEPS $TAURI_V2_DEPS # Use V2_DEPS as fallback for V1
          elif [[ "${{ inputs.app }}" == "tauri" ]]; then
            echo "Installing dependencies for Tauri v2 on Ubuntu 24.04 (Noble)"
            echo "--- apt-cache show libwebkit2gtk-4.1-dev ---"
            apt-cache show libwebkit2gtk-4.1-dev || echo "apt-cache show libwebkit2gtk-4.1-dev failed"
            echo "--- apt-cache search libjavascriptcoregtk-4.1-dev ---"
            apt-cache search libjavascriptcoregtk-4.1-dev || echo "apt-cache search libjavascriptcoregtk-4.1-dev failed"
            echo "--- End diagnostic searches ---"
            sudo apt-get install -y --no-install-recommends $COMMON_DEPS $TAURI_V2_DEPS
          else
            echo "::warning:: Unknown Tauri app type for dependency installation: ${{ inputs.app }}"
            # As a fallback, attempt to install common and v2 deps, but this might fail or be incorrect
            sudo apt-get install -y --no-install-recommends $COMMON_DEPS $TAURI_V2_DEPS
          fi

      - name: Install tauri-driver
        if: inputs.app == 'tauri' || inputs.app == 'tauri-v1'
        shell: bash
        run: |
          echo "Installing tauri-driver..."
          cargo install tauri-driver --locked
          if ! command -v tauri-driver &> /dev/null; then
            echo "::error::tauri-driver installation failed or not in PATH"
            exit 1
          fi
          echo "tauri-driver installed successfully."

      - name: Download shared packages artifact
        uses: actions/download-artifact@v4
        with:
          name: shared-packages
          path: packages/

      - name: Setup E2E Environment (Download Artifacts, Find App & WebKitWebDriver)
        id: setup_e2e
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APP_INPUT: ${{ inputs.app }}
          MODE_INPUT: ${{ inputs.mode }}
          APP_DIR_INPUT: ${{ inputs.app }}-example
          ARTIFACT_NAME_INPUT: ${{ needs.linux-build.outputs.artifact_name }}
          RELEASE_TAG_INPUT: ${{ env.RELEASE_TAG }}
        shell: bash
        run: |
          chmod +x .github/scripts/setup_e2e_linux.sh
          .github/scripts/setup_e2e_linux.sh

      - name: Execute E2E Tests
        run: |
          echo "Starting E2E tests for ${{ inputs.app }} (${{ inputs.mode }}) with app path: ${{ steps.setup_e2e.outputs.app_path }}"
          echo "E2E_APP_TYPE: ${{ inputs.app }}"
          echo "APP_DIR: ${{ inputs.app }}-example"
          echo "MODE: ${{ inputs.mode }}"
          echo "DISPLAY_ENV: $DISPLAY"
          echo "TAURI_WEBDRIVER_WEBKITDRIVER_PATH_ENV: $TAURI_WEBDRIVER_WEBKITDRIVER_PATH"

          if xvfb-run --auto-servernum --server-args="-screen 0 1280x1024x24" pnpm --filter=zubridge-e2e run exec; then
            echo "E2E tests passed for ${{ inputs.app }} (${{ inputs.mode }})."
          else
            echo "::error::E2E tests failed for ${{ inputs.app }} (${{ inputs.mode }}). Capturing debug info..."
            if [[ "${{ inputs.app }}" == "tauri" || "${{ inputs.app }}" == "tauri-v1" ]]; then
              TAURI_DRIVER_LOG_PATH="$HOME/.tauri/tauri-driver.log"
              echo "Attempting to display tauri-driver log from $TAURI_DRIVER_LOG_PATH:"
              if [ -f "$TAURI_DRIVER_LOG_PATH" ]; then
                tail -n 100 "$TAURI_DRIVER_LOG_PATH"
              else
                echo "tauri-driver.log not found at $TAURI_DRIVER_LOG_PATH. Listing $HOME/.tauri directory:"
                ls -la $HOME/.tauri 2>/dev/null || echo "$HOME/.tauri directory not found."
              fi
            fi
            exit 1
          fi
        env:
          APP_PATH: ${{ steps.setup_e2e.outputs.app_path }}
          E2E_APP_TYPE: ${{ inputs.app }}
          APP_DIR: ${{ inputs.app }}-example
          MODE: ${{ inputs.mode }}

      - name: Debugging Information on Failure (Screenshot & Processes)
        if: failure() && (inputs.app == 'tauri' || inputs.app == 'tauri-v1')
        shell: bash
        run: |
          echo "Attempting to capture Xvfb, application status, and screenshot after failure..."
          ps aux | grep Xvfb || echo "Xvfb not found in process list."
          ps aux | grep ${{ inputs.app }}-example || echo "App ${{ inputs.app }}-example not found in process list."

          echo "Taking screenshot using scrot..."
          export DISPLAY=${DISPLAY:-:99}
          echo "Using DISPLAY=$DISPLAY for screenshot attempt."
          if command -v scrot &> /dev/null; then
            scrot ${{ inputs.app }}-example-screenshot.png && echo "Screenshot saved to ${{ inputs.app }}-example-screenshot.png" || echo "Failed to take screenshot with scrot."
          else
            echo "scrot command not found, cannot take screenshot."
          fi
          ls -l *.png 2>/dev/null || echo "No png files found in current directory."

      - name: Handle Test Failures (Upload Logs and Screenshot)
        if: failure()
        uses: ./.github/workflows/actions/handle-e2e-failures
        with:
          app_type: ${{ inputs.app }}
          mode: ${{ inputs.mode }}
          os: linux
          log_path: "wdio-logs-${{ inputs.app }}-${{ inputs.mode }}/"
          screenshot_path: "${{ inputs.app }}-example-screenshot.png"

  # E2E Tests for macOS
  macos-test:
    needs: macos-build
    if: needs.macos-build.outputs.success == 'true' && inputs.app == 'electron' # Only run for successful electron builds
    name: macOS E2E
    runs-on: macOS-latest
    env:
      TURBO_TELEMETRY_DISABLED: 1
      TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
      TURBO_TEAM: ${{ secrets.TURBO_TEAM }}
      TURBO_API: ${{ secrets.TURBO_API }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Environment
        uses: ./.github/workflows/actions/setup-workspace
        with:
          node-version: "20"

      - name: Download shared packages
        uses: actions/download-artifact@v4
        with:
          name: shared-packages
          path: packages

      - name: Set up Node.js # Added for macOS
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'

      - name: Set up pnpm # Added for macOS
        uses: pnpm/action-setup@v3
        with:
          run_install: false

      - name: Get pnpm store directory # Added for macOS
        id: pnpm_store_path_step_macos
        shell: bash
        run: |
          STORE_PATH_VALUE=$(pnpm store path --silent)
          echo "STORE_PATH=$STORE_PATH_VALUE" >> $GITHUB_ENV
          echo "store_path=$STORE_PATH_VALUE" >> $GITHUB_OUTPUT

      - name: Setup pnpm cache # Added for macOS
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm_store_path_step_macos.outputs.store_path }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies # Added for macOS
        run: pnpm install --frozen-lockfile

      - name: Install tauri-driver
        if: (inputs.app == 'tauri' || inputs.app == 'tauri-v1') && runner.os != 'macOS' # Don't install if tauri on macOS
        shell: bash
        run: |
          echo "Installing tauri-driver..."
          cargo install tauri-driver --locked
          if ! command -v tauri-driver &> /dev/null; then
            echo "tauri-driver installation failed or not in PATH"
            exit 1
          fi
          echo "tauri-driver installed successfully."

      - name: Setup E2E Environment
        id: setup_e2e
        uses: ./.github/workflows/actions/setup-e2e-environment
        with:
          os: macOS-latest
          app: ${{ inputs.app }}
          mode: ${{ inputs.mode }}
          artifact_name: ${{ needs.macos-build.outputs.artifact_name }}

      - name: Execute E2E Tests
        run: |
          echo "Starting E2E tests for ${{ inputs.app }} (${{ inputs.mode }}) with app path: ${{ steps.setup_e2e.outputs.app_path }}"
          echo "E2E_APP_TYPE: ${{ inputs.app }}"
          echo "APP_DIR: ${{ inputs.app }}-example"
          echo "MODE: ${{ inputs.mode }}"
          echo "DISPLAY: $DISPLAY" # DISPLAY might not be relevant/set on macOS direct runners
          echo "TAURI_WEBDRIVER_WEBKITDRIVER_PATH: $TAURI_WEBDRIVER_WEBKITDRIVER_PATH"
          # For Electron on macOS, xvfb-run is generally not needed as there's a window server.
          # If tests are headless or specifically require Xvfb, it can be added, but usually not.
          pnpm --filter=zubridge-e2e run exec
        env:
          APP_PATH: ${{ steps.setup_e2e.outputs.app_path }}
          E2E_APP_TYPE: ${{ inputs.app }}
          APP_DIR: ${{ inputs.app }}-example
          MODE: ${{ inputs.mode }}
          # DISPLAY: $DISPLAY # Usually not needed for macOS
          TAURI_WEBDRIVER_WEBKITDRIVER_PATH: $TAURI_WEBDRIVER_WEBKITDRIVER_PATH

      - name: Verify Xvfb and App are Running (Debug)
        if: failure() && (inputs.app == 'tauri' || inputs.app == 'tauri-v1') # Will not run as job is electron only
        run: |
          echo "Attempting to capture Xvfb and application status..."
          ps aux | grep Xvfb || echo "Xvfb not running"
          ps aux | grep ${{ inputs.app }}-example || echo "App not running"
          # Add a small delay and try to take a screenshot
          sleep 5
          if command -v import &> /dev/null; then # 'import' is from ImageMagick, may not be available
            import -window root ${{ inputs.app }}-example-screenshot.png && echo "Screenshot taken." || echo "Failed to take screenshot."
            ls -l
          elif command -v screencapture &> /dev/null; then # macOS native screenshot utility
             screencapture ${{ inputs.app }}-example-screenshot.png && echo "Screenshot taken with screencapture." || echo "Failed to take screenshot with screencapture."
             ls -l
          else
            echo "scrot, import or screencapture command not found, cannot take screenshot."
          fi
        shell: bash

      - name: Handle Test Failures
        if: failure()
        uses: ./.github/workflows/actions/handle-e2e-failures
        with:
          os: macOS-latest
          app_type: ${{ inputs.app }} # Changed from 'app' to 'app_type' to match action input
          mode: ${{ inputs.mode }}
          # screenshot_path needs to be defined if we want to upload it.
          # The debug step above attempts to save it as ${{ inputs.app }}-example-screenshot.png

  # E2E Tests for Windows
  windows-test:
    needs: windows-build
    if: needs.windows-build.outputs.success == 'true'
    name: Windows E2E
    runs-on: windows-latest
    env:
      TURBO_TELEMETRY_DISABLED: 1
      TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
      TURBO_TEAM: ${{ secrets.TURBO_TEAM }}
      TURBO_API: ${{ secrets.TURBO_API }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Environment
        uses: ./.github/workflows/actions/setup-workspace
        with:
          node-version: "20"

      - name: Download shared packages
        uses: actions/download-artifact@v4
        with:
          name: shared-packages
          path: packages

      - name: Set up Node.js # Added for Windows
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'

      - name: Set up pnpm # Added for Windows
        uses: pnpm/action-setup@v3
        with:
          run_install: false

      - name: Get pnpm store directory # Added for Windows
        id: pnpm_store_path_step_windows
        shell: bash # Using bash for consistency, ensure runner has it or use pwsh
        run: |
          STORE_PATH_VALUE=$(pnpm store path --silent)
          echo "STORE_PATH=$STORE_PATH_VALUE" >> $GITHUB_ENV
          echo "store_path=$STORE_PATH_VALUE" >> $GITHUB_OUTPUT

      - name: Setup pnpm cache # Added for Windows
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm_store_path_step_windows.outputs.store_path }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies # Added for Windows
        run: pnpm install --frozen-lockfile

      - name: Install tauri-driver
        if: inputs.app == 'tauri' || inputs.app == 'tauri-v1'
        shell: bash
        run: |
          echo "Installing tauri-driver..."
          cargo install tauri-driver --locked # Added --locked
          echo "tauri-driver installation complete."
          # Verify installation path for Windows
          CARGO_HOME_BIN="$HOME/.cargo/bin/tauri-driver"
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            CARGO_HOME_BIN="$USERPROFILE/.cargo/bin/tauri-driver.exe"
          fi

          if [ -f "$CARGO_HOME_BIN" ]; then
            echo "tauri-driver found in $CARGO_HOME_BIN"
            # Add to PATH for this step if not already there by default installation
            echo "$USERPROFILE/.cargo/bin" >> $GITHUB_PATH
          else
            echo "tauri-driver NOT found in $CARGO_HOME_BIN after install attempt!"
            command -v tauri-driver || echo "tauri-driver not in PATH"
            exit 1 # Exit if not found, as it's critical
          fi

      - name: Setup E2E Environment
        id: setup_e2e
        uses: ./.github/workflows/actions/setup-e2e-environment
        with:
          os: windows-latest
          app: ${{ inputs.app }}
          mode: ${{ inputs.mode }}
          artifact_name: ${{ needs.windows-build.outputs.artifact_name }}

      - name: Execute E2E Tests
        env:
          APP_PATH: ${{ steps.setup_e2e.outputs.app_path }}
          DEBUG: "zubridge:*"
          E2E_APP_TYPE: ${{ inputs.app }}
          APP_DIR: ${{ inputs.app }}-example
          MODE: ${{ inputs.mode }}
        run: pnpm --filter=zubridge-e2e run exec
        shell: bash

      - name: Handle Test Failures
        if: failure()
        uses: ./.github/workflows/actions/handle-e2e-failures
        with:
          os: windows-latest
          app_type: ${{ inputs.app }} # Changed from 'app' to 'app_type'
          mode: ${{ inputs.mode }}
          # log_path: "wdio-logs-${{ inputs.app }}-${{ inputs.mode }}/" # Example if logs are saved here

  # Final status aggregation
  ci-status:
    name: Status
    needs: [linux-build, macos-build, windows-build, linux-test, macos-test, windows-test]
    if: always()
    runs-on: ubuntu-latest
    outputs:
      success: ${{ steps.check-status.outputs.success }}
    steps:
      - name: Check status
        id: check-status
        run: |
          FINAL_SUCCESS="true"
          if [[ "${{ needs.linux-build.result }}" == "failure" || \
                "${{ needs.macos-build.result }}" == "failure" || \
                "${{ needs.windows-build.result }}" == "failure" || \
                "${{ needs.linux-test.result }}" == "failure" || \
                ("${{ inputs.app }}" == "electron" && "${{ needs.macos-test.result }}" == "failure") || \
                "${{ needs.windows-test.result }}" == "failure" ]]; then
            FINAL_SUCCESS="false"
          fi

          if [[ "$FINAL_SUCCESS" == "true" ]]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "All relevant jobs passed or were skipped appropriately."
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "One or more jobs failed."
            exit 1
          fi
