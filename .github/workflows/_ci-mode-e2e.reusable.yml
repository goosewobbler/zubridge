name: E2E Tests
description: "Runs end-to-end tests across different modes"

on:
  workflow_call:
    inputs:
      os:
        description: "Operating system to run tests on"
        required: true
        type: string
      mode:
        description: "Test mode (basic, handlers, reducers, redux, or custom)"
        required: true
        type: string
      app:
        description: "Type of application to test (electron, tauri, tauri-v1)"
        required: true
        default: "electron"
        type: string
      build_id:
        description: "Build ID from the build job"
        type: string
        required: true
      artifact_name:
        description: "Name of the artifact to download"
        type: string
        required: true
      test_name:
        description: "Name of the test to use in job display (e.g., 'Linux', 'macOS', 'Windows')"
        type: string
        required: false
        default: "E2E"
    secrets:
      TURBO_TOKEN:
        description: 'Vercel token for Turborepo remote caching'
        required: false # Make these true if you always expect them
      TURBO_TEAM:
        description: 'Vercel team/scope slug for Turborepo remote caching'
        required: false
      TURBO_API:
        description: 'Vercel API endpoint for Turborepo remote caching'
        required: false

env:
  TURBO_TELEMETRY_DISABLED: 1
  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
  TURBO_TEAM: ${{ secrets.TURBO_TEAM }}
  TURBO_API: ${{ secrets.TURBO_API }}

jobs:
  e2e-mode:
    name: ${{ inputs.test_name }}
    runs-on: ${{ inputs.os }}
    steps:
      # Standard checkout
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Set up Node.js and PNPM
      - name: üõ†Ô∏è Setup Development Environment
        uses: ./.github/workflows/actions/setup-workspace
        with:
          node-version: "20"

      # Download the shared packages (built on Linux)
      - name: üì¶ Download Shared Packages
        uses: actions/download-artifact@v4
        with:
          name: shared-packages
          path: packages

      # Determine platform-specific paths and settings
      - name: Set platform-specific variables
        id: platform-vars
        shell: bash
        run: |
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            echo "platform=linux" >> $GITHUB_OUTPUT
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            echo "platform=macos" >> $GITHUB_OUTPUT
          elif [[ "${{ runner.os }}" == "Windows" ]]; then
            echo "platform=windows" >> $GITHUB_OUTPUT
          fi

      # Download the build artifacts directly to their final location
      - name: üì¶ Download ${{ inputs.app }}:${{ inputs.mode }} Build Artifacts
        id: download_app_artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact_name }}
          path: ${{ inputs.app == 'electron' && format('./apps/{0}-example/dist-{1}', inputs.app, inputs.mode) || format('./apps/{0}-example', inputs.app) }}

      # Display download information
      - name: üìä Show Download Information
        shell: bash
        run: |
          echo "Artifact ${{ inputs.artifact_name }} downloaded to target location"
          if [ "${{ inputs.app }}" == "electron" ]; then
            TARGET_DIR="./apps/${{ inputs.app }}-example/dist-${{ inputs.mode }}"
            echo "Electron artifacts in $TARGET_DIR:"
            ls -la "$TARGET_DIR"

            # Check platform-specific directories
            if [[ "${{ runner.os }}" == "Linux" ]]; then
              echo "Linux build directory:"
              if [ -d "$TARGET_DIR/linux-unpacked" ]; then
                ls -la "$TARGET_DIR/linux-unpacked"
                if [ -f "$TARGET_DIR/linux-unpacked/zubridge-electron-example-${{ inputs.mode }}" ]; then
                  echo "Executable exists and permissions:"
                  ls -la "$TARGET_DIR/linux-unpacked/zubridge-electron-example-${{ inputs.mode }}"
                else
                  echo "ERROR: Executable not found!"
                fi
              else
                echo "WARNING: linux-unpacked directory not found!"
              fi
            elif [[ "${{ runner.os }}" == "macOS" ]]; then
              echo "macOS build directory:"
              if [ -d "$TARGET_DIR/mac" ]; then
                ls -la "$TARGET_DIR/mac"
                if [ -d "$TARGET_DIR/mac/zubridge-electron-example-${{ inputs.mode }}.app" ]; then
                  echo "App bundle exists:"
                  ls -la "$TARGET_DIR/mac/zubridge-electron-example-${{ inputs.mode }}.app/Contents/MacOS/"
                else
                  echo "ERROR: App bundle not found!"
                fi
              else
                echo "WARNING: mac directory not found!"
              fi
            elif [[ "${{ runner.os }}" == "Windows" ]]; then
              echo "Windows build directory:"
              if [ -d "$TARGET_DIR/win-unpacked" ]; then
                ls -la "$TARGET_DIR/win-unpacked"
                if [ -f "$TARGET_DIR/win-unpacked/zubridge-electron-example-${{ inputs.mode }}.exe" ]; then
                  echo "Executable exists:"
                  ls -la "$TARGET_DIR/win-unpacked/zubridge-electron-example-${{ inputs.mode }}.exe"
                else
                  echo "ERROR: Executable not found!"
                fi
              else
                echo "WARNING: win-unpacked directory not found!"
              fi
            fi
          elif [[ "${{ inputs.app }}" == "tauri" || "${{ inputs.app }}" == "tauri-v1" ]]; then
            TARGET_DIR="./apps/${{ inputs.app }}-example"
            echo "Tauri artifacts in $TARGET_DIR:"
            ls -la "$TARGET_DIR"

            # Check expected sub-directories
            if [ -d "$TARGET_DIR/dist" ]; then
              echo "dist/ directory found"
              ls -la "$TARGET_DIR/dist"
            fi

            if [ -d "$TARGET_DIR/src-tauri/target" ]; then
              echo "src-tauri/target/ directory found"
              ls -la "$TARGET_DIR/src-tauri/target"
            fi
          fi

      # Display build information
      - name: üìä Show Build Information
        shell: bash
        run: |
          echo "::notice::Running E2E tests for ${{ inputs.app }}:${{ inputs.mode }} mode on ${{ inputs.os }} with build ID ${{ inputs.build_id }}"

      # Special workaround for Linux to enable Electron testing
      - name: üîß Apply Linux Kernel Workaround
        if: inputs.app == 'electron' && runner.os == 'Linux'
        shell: bash
        run: sudo sysctl -q -w kernel.apparmor_restrict_unprivileged_userns=0

      # Run the E2E tests for the provided app and mode
      - name: üß™ Execute E2E Tests for ${{ inputs.app }}:${{ inputs.mode }}
        shell: bash
        run: pnpm run test:e2e:${{ inputs.app }}-${{ inputs.mode }} --concurrency=1

      # Show logs on failure
      - name: üêõ Show Test Logs on Failure
        shell: bash
        if: failure() && inputs.app == 'electron'
        run: cat ./e2e/wdio-logs-${{ inputs.app }}-${{ inputs.mode }}/*.log || echo "No log files found"

      # Upload logs as artifacts on failure
      - name: üì¶ Upload Test Logs on Failure
        uses: actions/upload-artifact@v4
        if: failure() && inputs.app == 'electron'
        with:
          name: e2e-logs-${{ inputs.os }}-${{ inputs.app }}-${{ inputs.mode }}
          path: e2e/wdio-logs-${{ inputs.app }}-${{ inputs.mode }}/*.log
          retention-days: 30
          if-no-files-found: warn

      # Provide an interactive debugging session on failure
      - name: üêõ Debug on Failure
        uses: stateful/vscode-server-action@v1.1.0
        if: failure()
        with:
          timeout: "180000"
