name: E2E Tests
description: "Runs end-to-end tests across different modes"

on:
  workflow_call:
    inputs:
      os:
        description: "Operating system to run tests on"
        required: true
        type: string
      mode:
        description: "Test mode (basic, handlers, reducers, redux, or custom)"
        required: true
        type: string
      app:
        description: "Type of application to test (electron, tauri, tauri-v1)"
        required: true
        default: "electron"
        type: string
      build_id:
        description: "Build ID from the build job"
        type: string
        required: true
      artifact_name:
        description: "Name of the artifact to download"
        type: string
        required: true
    secrets:
      TURBO_TOKEN:
        description: 'Vercel token for Turborepo remote caching'
        required: false # Make these true if you always expect them
      TURBO_TEAM:
        description: 'Vercel team/scope slug for Turborepo remote caching'
        required: false
      TURBO_API:
        description: 'Vercel API endpoint for Turborepo remote caching'
        required: false

env:
  TURBO_TELEMETRY_DISABLED: 1
  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
  TURBO_TEAM: ${{ secrets.TURBO_TEAM }}
  TURBO_API: ${{ secrets.TURBO_API }}

jobs:
  e2e-mode:
    name: E2E
    runs-on: ${{ inputs.os }}
    steps:
      # Standard checkout
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Set up Node.js and PNPM
      - name: üõ†Ô∏è Setup Development Environment
        uses: ./.github/workflows/actions/setup-workspace
        with:
          node-version: "20"

      # Download the shared packages (built on Linux)
      - name: üì¶ Download Shared Packages
        uses: actions/download-artifact@v4
        with:
          name: shared-packages
          path: packages

      # Download the build artifacts specifically for this mode (built on Linux)
      - name: üì¶ Download ${{ inputs.app }}:${{ inputs.mode }} Build Artifacts
        id: download_app_artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact_name }}
          path: .

      # Place downloaded artifacts correctly
      - name: üöö Place Downloaded Artifacts Correctly
        shell: bash
        run: |
          set -e
          echo "Attempting to place artifacts for ${{ inputs.app }} mode ${{ inputs.mode }}"

          # When download-artifact uses 'path: .', it creates a directory named after the artifact
          # in the current directory ('.').
          # inputs.artifact_name is the name like 'electron-basic-XYZ'
          ARTIFACT_SUBDIR="./${{ inputs.artifact_name }}"
          echo "Expecting artifact contents in subdirectory: $ARTIFACT_SUBDIR"

          TARGET_APP_BASE_DIR="./apps/${{ inputs.app }}-example"
          mkdir -p "$TARGET_APP_BASE_DIR"
          echo "Target app base directory: $TARGET_APP_BASE_DIR"

          if [ "${{ inputs.app }}" == "electron" ]; then
            SOURCE_SPECIFIC_DIR="$ARTIFACT_SUBDIR/dist-${{ inputs.mode }}"
            if [ ! -d "$SOURCE_SPECIFIC_DIR" ]; then
              echo "::error::Electron source dir '$SOURCE_SPECIFIC_DIR' not found!"
              echo "Listing contents of expected artifact subdirectory '$ARTIFACT_SUBDIR':"
              ls -la "$ARTIFACT_SUBDIR" || echo "Directory $ARTIFACT_SUBDIR not found or ls failed"
              echo "Also listing current directory (workspace root):"
              ls -la .
              exit 1
            fi
            echo "Moving Electron dir '$SOURCE_SPECIFIC_DIR' to '$TARGET_APP_BASE_DIR/'"
            mv "$SOURCE_SPECIFIC_DIR" "$TARGET_APP_BASE_DIR/"
            echo "Electron artifacts moved to $TARGET_APP_BASE_DIR/dist-${{ inputs.mode }}"
            ls -la "$TARGET_APP_BASE_DIR/dist-${{ inputs.mode }}"
          elif [[ "${{ inputs.app }}" == "tauri" || "${{ inputs.app }}" == "tauri-v1" ]]; then
            SOURCE_DIST_DIR="$ARTIFACT_SUBDIR/dist"
            SOURCE_TARGET_DIR="$ARTIFACT_SUBDIR/src-tauri/target"

            if [ -d "$SOURCE_DIST_DIR" ]; then
              echo "Moving Tauri 'dist' dir '$SOURCE_DIST_DIR' to '$TARGET_APP_BASE_DIR/'"
              mv "$SOURCE_DIST_DIR" "$TARGET_APP_BASE_DIR/"
              echo "Tauri 'dist' moved to $TARGET_APP_BASE_DIR/dist"
              ls -la "$TARGET_APP_BASE_DIR/dist"
            else
              echo "::warning::Tauri 'dist' dir '$SOURCE_DIST_DIR' not found in downloaded artifact."
              ls -la "$ARTIFACT_SUBDIR" || echo "Directory $ARTIFACT_SUBDIR not found or ls failed"
            fi

            if [ -d "$SOURCE_TARGET_DIR" ]; then
              mkdir -p "$TARGET_APP_BASE_DIR/src-tauri"
              echo "Moving Tauri 'src-tauri/target' dir '$SOURCE_TARGET_DIR' to '$TARGET_APP_BASE_DIR/src-tauri/'"
              mv "$SOURCE_TARGET_DIR" "$TARGET_APP_BASE_DIR/src-tauri/"
              echo "Tauri 'src-tauri/target' moved to $TARGET_APP_BASE_DIR/src-tauri/target"
              ls -la "$TARGET_APP_BASE_DIR/src-tauri/target"
            else
              echo "::warning::Tauri 'src-tauri/target' dir '$SOURCE_TARGET_DIR' not found in downloaded artifact."
            fi
          else
            echo "::error::Unknown app type '${{ inputs.app }}' for artifact placement."
            exit 1
          fi
          echo "Artifact placement complete."

      # Display build information
      - name: üìä Show Build Information
        shell: bash
        run: |
          echo "::notice::Running E2E tests for ${{ inputs.app }}:${{ inputs.mode }} mode on ${{ inputs.os }} with build ID ${{ inputs.build_id }}"

      # Special workaround for Linux to enable Electron testing
      - name: üîß Apply Linux Kernel Workaround
        if: inputs.app == 'electron' && runner.os == 'Linux'
        shell: bash
        run: sudo sysctl -q -w kernel.apparmor_restrict_unprivileged_userns=0

      # Run the E2E tests for the provided app and mode
      - name: üß™ Execute E2E Tests for ${{ inputs.app }}:${{ inputs.mode }}
        shell: bash
        run: pnpm run test:e2e:${{ inputs.app }}-${{ inputs.mode }} --concurrency=1

      # Show logs on failure
      - name: üêõ Show Test Logs on Failure
        shell: bash
        if: failure() && inputs.app == 'electron'
        run: cat ./e2e/wdio-logs-${{ inputs.app }}-${{ inputs.mode }}/*.log || echo "No log files found"

      # Upload logs as artifacts on failure
      - name: üì¶ Upload Test Logs on Failure
        uses: actions/upload-artifact@v4
        if: failure() && inputs.app == 'electron'
        with:
          name: e2e-logs-${{ inputs.os }}-${{ inputs.app }}-${{ inputs.mode }}
          path: e2e/wdio-logs-${{ inputs.app }}-${{ inputs.mode }}/*.log
          retention-days: 30
          if-no-files-found: warn

      # Provide an interactive debugging session on failure
      - name: üêõ Debug on Failure
        uses: stateful/vscode-server-action@v1.1.0
        if: failure()
        with:
          timeout: "180000"
